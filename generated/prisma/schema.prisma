generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// enum Role {
//   USER
//   ADMIN
// }

// enum Plan {
//   FREE
//   PRO
//   PREMIUM
// }

// model Post {
//   id         String              @id @default(cuid())
//   img        String?
//   title      String
//   content    String?
//   published  Boolean             @default(false)
//   desc       String?
//   createdAt  DateTime            @default(now())
//   views      Int                 @default(0)
//   slug       String?             @unique
//   catSlug    String?
//   // authorId   String?
//   // author     User?               @relation(fields: [authorId], references: [id])
//   categories CategoriesOnPosts[]
// }

// model Category {
//   id        String              @id @default(cuid())
//   title     String?
//   img       String?
//   desc      String?
//   name      String?
//   slug      String?             @unique
//   createdAt DateTime            @default(now())
//   posts     CategoriesOnPosts[]
// }

// model CategoriesOnPosts {
//   postId     String
//   categoryId String
//   assignedAt DateTime @default(now())
//   assignedBy String
//   category   Category @relation(fields: [categoryId], references: [id])
//   post       Post     @relation(fields: [postId], references: [id])

//   @@id([postId, categoryId])
// }

// Required for creating a Store: userId, name, username, email, contact, logo, description, address (optional: , status, isActive)
// model Store {
//   id          String   @id @default(uuid())
//   name        String
//   description String
//   username    String   @unique
//   address     String
//   status      String   @default("pending")
//   isActive    Boolean  @default(false)
//   logo        String
//   email       String
//   contact     String
//   createdAt   DateTime @default(now())
//   updatedAt   DateTime @updatedAt
// }
// enum OrderStatus {
//   ORDER_PLACED
//   PROCESSING
//   SHIPPED
//   DELIVERED
// }
// enum PaymentMethod {
//   COD
//   STRIPE
// }
// model Profile {
//   id      String  @id @default(uuid())
//   address String?
//Relation
// userId String @unique
// users  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
// }
// model Payment {
//   id          String   @id @default(uuid())
//   amount      Decimal
//   paymentDate DateTime @default(now())

//Relation
// orderId String @unique
// order   Order  @relation(fields: [orderId], references: [id])
// }
// model Shipment {
//   id             String   @id @default(uuid())
//   shippingDate   DateTime @default(now())
//   trackingNumber String
//Relation
// orderId        String   @unique
// order          Order    @relation(fields: [orderId], references: [id])
// }
//Optional for WebAuthn support
// model AuthenticatorAuthjs {
//   credentialID         String  @unique
//   providerAccountId    String
//   credentialPublicKey  String
//   counter              Int
//   credentialDeviceType String
//   credentialBackedUp   Boolean
//   transports           String?

//   //Relation
//   userId String
//   users  User   @relation(fields: [userId], references: [id], onDelete: Cascade)

//   @@id([userId, credentialID])
// }

// Required for creating a Product: name, description, mrp, price, images, category, storeId

model File {
  id           String   @id @default(uuid())
  name         String
  path         String
  size         Int
  type         String
  fileUrl      String   @map("file_url")
  thumbnailUrl String?  @map("thumbnail_url")
  parentId     String?  @map("parent_id")
  isFolder     Boolean  @default(false) @map("is_folder")
  isStarred    Boolean  @default(false) @map("is_starred")
  isTrash      Boolean  @default(false) @map("is_trash")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  //Relation
  userId String?
  users  User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Self-relation for parent/children
  parent   File?  @relation("FileToFile", fields: [parentId], references: [id])
  children File[] @relation("FileToFile")

  @@map("files")
}

//===================================================================
model ProductReviewTable {
  id         String   @id @default(uuid())
  rating     Decimal  @db.Decimal(3, 2) //- rating → ใช้ Decimal พร้อมกำหนด precision (3,2)
  comment    String?
  created_at DateTime @default(now())

  //Relation
  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: Cascade)

  productId String?
  product   Product? @relation(fields: [productId], references: [id])
}

model Product {
  id              String   @id @default(uuid())
  name            String?
  name_eng        String?
  description     String?
  image           String?
  image_url       String?
  price           Float?
  stock           Int?
  category        String?
  ratings         Decimal?
  status          String?
  stripePriceId   String?
  stripeProductId String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  orders              Order[]
  orderItems          OrderItem[]
  invoiceItems        InvoiceItem[]
  productReviewTables ProductReviewTable[]
}

model products_desserts {
  dessert_id      String   @id @default(uuid())
  name            String?  @db.VarChar(255)
  name_eng        String?  @db.VarChar(255)
  description     String?
  price           Float?
  stock           Int?
  category        String?
  ratings         Decimal?
  status          String?
  image           String?  @db.VarChar(255)
  image_url       String   @db.VarChar(255)
  stripePriceId   String?
  stripeProductId String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  //Relation
}

//==========================================================================

model Customers {
  id        String @id @default(uuid())
  name      String
  email     String @unique
  image_url String

  invoices Invoices[]
}

model Invoices {
  id     String   @id @default(uuid())
  amount Decimal
  status String   @default("pending")
  date   DateTime @default(now())

  //Relation
  customerId String
  customers  Customers @relation(fields: [customerId], references: [id])
}

model Revenue {
  month   String @unique @db.VarChar(4)
  revenue Int
}

//==================================================================================

model Customer {
  id        String  @id @default(uuid())
  name      String?
  email     String? @unique
  image_url String?

  //Relation
  userId              String?              @unique
  users               User?                @relation(fields: [userId], references: [id], onDelete: Cascade)
  address             Address[]
  orders              Order[]
  invoices            Invoice[]
  productReviewTables ProductReviewTable[]
}

//https://www.youtube.com/watch?v=Mcw8Mp8PYUE
//https://github.com/colbyfayock/my-invoicing-app/blob/main/src/db/schema.ts

model Invoice {
  id     String    @id @default(uuid())
  amount Decimal?
  status String?   @default("pending")
  date   DateTime? @default(now())

  //Relation
  customerId   String
  customers    Customer      @relation(fields: [customerId], references: [id], onDelete: Cascade)
  invoiceItems InvoiceItem[]
}

model InvoiceItem {
  id       String  @id @default(uuid())
  quantity Int
  price    Decimal

  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  productId String?
  product   Product? @relation(fields: [productId], references: [id])
}

model OrderItem {
  id       String  @id @default(uuid())
  quantity Int
  price    Float
  image    String?
  title    String?

  //Relation
  orderId   String
  orders    Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([orderId, productId])
}

// enum OrderStatus {
//   Processing
//   Shipped
//   Delivered
//   Cancelled
// }

model Order {
  id                String    @id @default(uuid())
  quantity          Int?
  price             Decimal?
  paymentMethod     String?
  status            String?   @default("pending")
  stripe_session_id String?
  paid_at           DateTime?
  tax_price         Decimal?
  shipping_price    Decimal?
  total_price       Decimal?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  //Relation 
  customerId   String?
  customer     Customer?     @relation(fields: [customerId], references: [id], onDelete: Cascade)
  productId    String?
  product      Product?      @relation(fields: [productId], references: [id])
  items        OrderItem[]
  payment      Payment?
  shippingInfo ShippingInfo?
}

model ShippingInfo {
  id          String   @id @default(uuid())
  name        String
  email       String
  street      String
  city        String
  state       String
  zip         String
  country     String
  phone       String
  description String?
  createdAt   DateTime @default(now())

  // Relation
  orderId String @unique
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

// enum PaymentType {
//   Online
// }

// enum PaymentStatus {
//   Paid
//   Pending
//   Failed
// }

model Payment {
  id              String   @id @default(uuid())
  amount          Decimal?
  paymentDate     DateTime @default(now())
  stripePriceId   String?
  stripeProductId String?
  status          String?  @default("pending")
  provider        String?  @default("stripe")
  type_payment    String?  @default("credit_card")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  //Relation
  orderId String? @unique
  order   Order?  @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

// Required for creating an Address: userId, name, email, street, city, state, zip, country, phone
model Address {
  id          String   @id @default(uuid())
  name        String
  email       String
  street      String
  city        String
  state       String
  zip         String
  country     String
  phone       String
  description String?
  createdAt   DateTime @default(now())

  // Relations 
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
}

//===========================================================================
enum Role {
  member
  admin
  owner
}

model User {
  id            String    @id @default(uuid())
  name          String?
  password      String?
  email         String    @unique
  emailVerified Boolean?  @default(false)
  image         String?
  role          Role?     @default(member)
  createdAt     DateTime? @default(now())
  updatedAt     DateTime? @updatedAt

  // Relations 
  sessions    Session[]
  accounts    Account[]
  invitations Invitation[]
  members     Member[]
  files       File[]
  customer    Customer?

  //   // Optional for WebAuthn support
  // authenticatorAuthjs AuthenticatorAuthjs[]  
}

model Session {
  id                   String    @id @default(uuid()) // Unique identifier for each session 
  token                String?   @unique // Unique session token 
  expiresAt            DateTime? // Expiration time of the session 
  ipAddress            String? // IP address of the device (optional)
  userAgent            String? // User agent information (optional)
  createdAt            DateTime? @default(now()) // Timestamp when session was created
  updatedAt            DateTime? @updatedAt // Timestamp when session was updated
  activeOrganizationId String?

  // Relation: เชื่อมกับ User table
  userId String // The ID of the user
  users  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Account {
  id                    String    @id @default(uuid()) // Unique identifier for each account ของเก่าเป็น @default(cuid())
  accountId             String? // Account ID from SSO or equal to userId for credentials
  providerId            String? // Provider ID (e.g. google, github, etc.) 
  accessToken           String? // Access token returned by provider
  refreshToken          String? // Refresh token returned by provider ของเก่า refresh_token
  accessTokenExpiresAt  DateTime? // Expiration time of access token
  refreshTokenExpiresAt DateTime? // Expiration time of refresh token refresh_token_expires_in Int?
  scope                 String? // Scope returned by provider
  idToken               String? // ID token returned by provider ของเก่า id_token
  password              String? // Password (for email/password auth)
  createdAt             DateTime? @default(now()) // Timestamp when account was created
  updatedAt             DateTime? @updatedAt // Timestamp when account was updated

  // Relation: เชื่อมกับ User table
  userId String // The ID of the user
  users  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Verification {
  id         String    @id @default(uuid()) // Unique identifier for each verification
  identifier String? // Identifier for the verification request (เช่น email หรือ phone)
  value      String? // Value ที่ต้องการตรวจสอบ (เช่น code หรือ token)
  expiresAt  DateTime? // เวลาหมดอายุของ verification request
  createdAt  DateTime? @default(now()) // เวลาที่สร้าง request
  updatedAt  DateTime? @updatedAt // เวลาที่แก้ไขล่าสุด
}

model Invitation {
  id        String   @id @default(uuid()) // Primary key
  email     String
  role      Role?
  status    String   @default("pending")
  expiresAt DateTime

  // Relations
  organizationId String
  organizations  Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  inviterId      String
  inviter        User         @relation(fields: [inviterId], references: [id], onDelete: Cascade)
}

//=============================================================================
model Member {
  id        String   @id @default(uuid())
  role      Role?    @default(member) // ใช้ enum Role
  createdAt DateTime @default(now())

  // Relations
  organizationId String
  organizations  Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  userId String
  users  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Organization {
  id        String   @id @default(uuid()) // Primary key
  name      String // ชื่อองค์กร
  slug      String?  @unique // slug ต้อง unique และเป็น optional
  logo      String? // โลโก้ (optional)
  createdAt DateTime @default(now()) // เวลาสร้าง
  metadata  String? // metadata (optional)

  // Relations
  members     Member[] // 1 Organization → หลาย Member
  invitations Invitation[]
}

//====================================================================================
// 1. Model User (ผู้ใช้งาน)
// เป็น ศูนย์กลาง ของระบบ Authentication เก็บข้อมูลพื้นฐานของผู้ใช้ เช่น ชื่อ, อีเมล, รหัสผ่าน (ถ้ามี), รูปโปรไฟล์ และ Role

// ความสัมพันธ์: เป็น "One" ในความสัมพันธ์แบบ One-to-Many กับ Session, Account, และ Member
// 2. Model Session (เซสชันการใช้งาน)
// ใช้สำหรับเก็บสถานะการเข้าสู่ระบบของผู้ใช้ (Stateful Session)

// ความสัมพันธ์กับ User: N:1 (Many-to-One)
// 1 User มีได้หลาย Session: ผู้ใช้คนเดียวสามารถล็อกอินค้างไว้ได้หลายอุปกรณ์พร้อมกัน (เช่น บนมือถือ และ บนคอมพิวเตอร์)
// การเชื่อมโยง: ในตาราง Session จะมีฟิลด์ userId ที่อ้างอิงไปยัง id ของตาราง User
// Better-Auth: ใช้ตรวจสอบว่า Request นี้มาจากผู้ใช้คนไหน และ Session หมดอายุหรือยัง
// 3. Model Account (บัญชีเชื่อมต่อ)
// ใช้สำหรับเก็บข้อมูลการเชื่อมต่อกับผู้ให้บริการภายนอก (OAuth Providers) เช่น Google, GitHub, Facebook

// ความสัมพันธ์กับ User: N:1 (Many-to-One)
// 1 User มีได้หลาย Account: ผู้ใช้ 1 คน สามารถผูกบัญชี Google และ GitHub เข้ากับ User ID เดียวกันได้
// การเชื่อมโยง: ในตาราง Account จะมีฟิลด์ userId ที่อ้างอิงไปยัง id ของตาราง User
// ข้อมูลที่เก็บ: providerId (เช่น "google"), accountId (ID จาก Google), accessToken, refreshToken เพื่อใช้ในการเรียก API ของ Provider นั้นๆ แทนผู้ใช้
// 4. Model Verification (การยืนยันตัวตน)
// ใช้สำหรับเก็บ Token ชั่วคราวสำหรับกระบวนการยืนยันต่างๆ เช่น การยืนยันอีเมล (Email Verification), การรีเซ็ตรหัสผ่าน (Password Reset), หรือ OTP

// ความสัมพันธ์: ไม่มีความสัมพันธ์แบบ Foreign Key โดยตรงกับ User (ใน Schema นี้)
// การทำงาน: จะใช้ฟิลด์ identifier (เช่น อีเมล หรือ เบอร์โทร) คู่กับ value (Token/Code) เพื่อตรวจสอบความถูกต้อง
// เหตุผล: เพราะบางครั้งการยืนยันตัวตนเกิดขึ้น ก่อน ที่จะมี User ในระบบ (เช่น ตอนสมัครสมาชิกใหม่) หรือใช้เพื่อยืนยันความเป็นเจ้าของ Identifier นั้นๆ
// 5. Model Invitation (คำเชิญ)
// ใช้สำหรับระบบ Organization (Team) เพื่อเชิญคนอื่นเข้าร่วมทีม

// ความสัมพันธ์กับ Organization: N:1
// คำเชิญ 1 ใบ จะผูกกับ 1 องค์กร (organizationId)
// ความสัมพันธ์กับ User (ผู้เชิญ): N:1
// ฟิลด์ inviterId จะอ้างอิงไปยัง User ที่เป็นคนกดส่งคำเชิญ (Inviter)
// ความสัมพันธ์กับผู้ถูกเชิญ:
// ใช้ฟิลด์ email เพื่อระบุเป้าหมาย (ไม่ได้ผูก User ID โดยตรง เพราะผู้ถูกเชิญอาจจะยังไม่ได้สมัครสมาชิกในระบบ)
// [User] 
//   │ (1)
//   ├───< (N) [Session] (ล็อกอินหลายเครื่อง)
//   │
//   ├───< (N) [Account] (ผูก Google, GitHub)
//   │
//   ├───< (N) [Member] (เป็นสมาชิกหลายองค์กร)
//   │
//   └───< (N) [Invitation] (เป็นคนส่งคำเชิญ)

// [Verification] (แยกอิสระ ใช้ identifier ตรวจสอบ)

// [Organization]
//   │ (1)
//   ├───< (N) [Member]
//   └───< (N) [Invitation]
//
// Model User: เป็นตัวแทนของ "บัญชีผู้ใช้" (Authentication) เก็บ Email, Password, Role, และ Session
// Model Customer: เป็นตัวแทนของ "ผู้ซื้อ" (Business Profile) เก็บประวัติการสั่งซื้อ (Order), ใบแจ้งหนี้ (Invoice), ที่อยู่ (Address)
// การกำหนดสิทธิ์ (Permission Logic)
// หลักการคือเราจะใช้ role ใน User เป็นตัวกำหนดขอบเขตการเข้าถึงข้อมูล (Scope of Access)

// A. สิทธิ์ระดับ Customer (User ทั่วไป)
// กฎ: "ฉันแก้ไขได้แค่ข้อมูลของฉันเอง"
// Logic: เมื่อ Query ฐานข้อมูล ต้อง มีเงื่อนไข where: { userId: currentUserId } เสมอ เพื่อป้องกันไม่ให้ไปยุ่งกับข้อมูลคนอื่น
// B. สิทธิ์ระดับ Admin
// กฎ: "ฉันแก้ไขข้อมูลของใครก็ได้"
// Logic: สามารถ Query ด้วย id ของ Customer คนไหนก็ได้ โดยไม่ต้องเช็ค userId ของคนทำรายการ (แต่ต้องเช็คว่าคนทำรายการมี role เป็น admin)
// "use server";

// import prisma from "@/lib/prisma";
// import { auth } from "@/auth"; // สมมติว่าใช้ auth v5 หรือ better-auth
// import { redirect } from "next/navigation";

// // สมมติว่ารับข้อมูลเข้ามาเพื่อแก้ไข Profile หรือ Address
// export async function updateCustomerProfile(
//   targetCustomerId: string, 
//   data: { name: string; phone: string }
// ) {
//   // 1. ตรวจสอบ Session (Authentication)
//   const session = await auth();
//   if (!session || !session.user) {
//     redirect("/login");
//   }

//   const currentUser = session.user;

//   // 2. ตรวจสอบสิทธิ์ (Authorization)

//   // กรณี: เป็น ADMIN
//   if (currentUser.role === "admin") {
//     // Admin สามารถแก้ไข Customer คนไหนก็ได้ ตาม targetCustomerId ที่ส่งมา
//     return await prisma.customer.update({
//       where: { id: targetCustomerId },
//       data: {
//         name: data.name,
//         // Admin อาจจะแก้ไขข้อมูลอื่นๆ ได้มากกว่า
//       },
//     });
//   }

//   // กรณี: เป็น CUSTOMER (User ทั่วไป)
//   if (currentUser.role === "customer" || currentUser.role === "member") {
//     // 2.1 ต้องหา Customer Profile ของ User คนนี้ก่อน
//     const myCustomerProfile = await prisma.customer.findUnique({
//       where: { userId: currentUser.id }, // ค้นหาจาก ID ของตัวเองเท่านั้น!
//     });

//     if (!myCustomerProfile) {
//       throw new Error("Customer profile not found");
//     }

//     // 2.2 ป้องกันการสวมรอย: เช็คว่า ID ที่ส่งมา ตรงกับ Profile ของตัวเองไหม
//     if (myCustomerProfile.id !== targetCustomerId) {
//       throw new Error("Unauthorized: You can only edit your own profile");
//     }

//     // 2.3 อัปเดตข้อมูล (Scope แค่ของตัวเอง)
//     return await prisma.customer.update({
//       where: { id: myCustomerProfile.id },
//       data: {
//         name: data.name,
//         // User ทั่วไปอาจแก้ไขได้จำกัดฟิลด์
//       },
//     });
//   }

//   throw new Error("Forbidden");
// }
// User Model: ใช้ระบุตัวตนว่า "คุณคือใคร" และ "คุณเป็น Admin หรือ Customer"
// Customer Model: ใช้เก็บข้อมูลที่ถูกกระทำ (Data Resource)
// Admin Access: เข้าถึงผ่าน Primary Key (id) ของ Customer ได้โดยตรง
// Customer Access: เข้าถึงผ่าน Foreign Key (userId) ของตัวเองเสมอ เพื่อจำกัดสิทธิ์ (Sandboxing)
//============================================================================
// User (1) ──── (1) Customer ────< (N) Address
//                   │
//                   ├───< (N) Order ────< (N) OrderItem >──── (1) Product
//                   │        │
//                   │        └─── (1) Payment
//                   │
//                   └───< (N) Invoice ────< (N) InvoiceItem >──── (1) Product
//
// User (1) ──── (1) Customer: ผู้ใช้งาน (User) หนึ่งคน ผูกกับข้อมูลลูกค้า (Customer) หนึ่งชุด
// Customer: เป็นศูนย์กลางที่เชื่อมโยงไปยังข้อมูลสำคัญ 3 ส่วน:
// Address: ลูกค้ามีได้หลายที่อยู่
// Order: ลูกค้ามีได้หลายคำสั่งซื้อ -> ซึ่ง Order จะมีรายการสินค้า (OrderItem) และการชำระเงิน (Payment)
// Invoice: ลูกค้ามีใบแจ้งหนี้ได้หลายใบ -> ซึ่ง Invoice จะมีรายการในใบแจ้งหนี้ (InvoiceItem)
// Product: ถูกอ้างอิงโดยทั้ง OrderItem (ตอนสั่งซื้อ) และ InvoiceItem (ตอนออกใบแจ้งหนี้)
//
//  ในการออกแบบ Database Schema สำหรับระบบ E-commerce ทั่วไป ความหมายของแต่ละ Model จะเป็นดังนี้ครับ:

// Order (ใบสั่งซื้อ): คือข้อมูลส่วนหัวของเอกสาร (Header) เช่น ใครเป็นคนสั่ง (User), สั่งเมื่อไหร่, สถานะเป็นอย่างไร, ที่อยู่จัดส่งที่ไหน
// OrderItem (รายการสินค้าในใบสั่งซื้อ): คือรายละเอียดของสินค้าแต่ละรายการที่อยู่ในใบสั่งซื้อนั้นๆ (Line Items) เช่น สั่งสินค้า A จำนวน 2 ชิ้น, สินค้า B จำนวน 1 ชิ้น
// Invoices (ใบแจ้งหนี้): คือเอกสารใบแจ้งหนี้ (Header)
// InvoiceItem (รายการสินค้าในใบแจ้งหนี้): คือรายละเอียดสินค้าที่ระบุในใบแจ้งหนี้นั้นๆ
// 1. ความสัมพันธ์ของ Model (Relationships)
// Customer 1 : N Order (ลูกค้า 1 คน มีได้หลายคำสั่งซื้อ)
// Customer: เป็นเจ้าของคำสั่งซื้อ ในตาราง Order จะมีฟิลด์ customerId เพื่อระบุว่าใครเป็นคนสั่ง
// Order 1 : N OrderItem (คำสั่งซื้อ 1 ใบ มีสินค้าได้หลายรายการ)
// Order: เปรียบเสมือน "หัวบิล" เก็บข้อมูลภาพรวม เช่น วันที่สั่ง, ราคารวม, สถานะ (Pending/Paid), และการเชื่อมโยงไปหา Customer
// OrderItem: เปรียบเสมือน "รายการสินค้าในบิล" (Line Items) เช่น บรรทัดที่ 1 คือสินค้า A จำนวน 2 ชิ้น, บรรทัดที่ 2 คือสินค้า B จำนวน 1 ชิ้น
// OrderItem N : 1 Product (รายการสินค้าแต่ละบรรทัด อ้างอิงสินค้า 1 ชนิด)
// OrderItem: จะเก็บ productId เพื่อบอกว่าเป็นสินค้าตัวไหน และเก็บ quantity (จำนวน) กับ price (ราคา ณ ตอนที่ซื้อ) ไว้ด้วย
// Product: เก็บข้อมูลสินค้าหลัก เช่น ชื่อ, รายละเอียด, สต็อก
// Order 1 : 1 Payment (คำสั่งซื้อ 1 ใบ มีการชำระเงิน 1 รายการ)
// Payment: เก็บรายละเอียดการจ่ายเงิน เช่น วันที่จ่าย, ยอดเงิน, วิธีการจ่าย (Credit Card/Stripe) โดยเชื่อมกับ Order ผ่าน orderId
// 2. ตัวอย่างขั้นตอนการดำเนินการสั่งซื้อ (Order Process Flow)
// สมมติว่า Customer (นาย A) ต้องการซื้อ Product (iPhone 15) จำนวน 1 เครื่อง และ Product (Case) จำนวน 2 ชิ้น ขั้นตอนในระบบจะเป็นดังนี้:

// Step 1: สร้างคำสั่งซื้อ (Create Order)
// ระบบจะสร้าง Record ในตาราง Order ก่อน เพื่อเป็นหัวบิล

// Model Order:
// id: "order-001"
// customerId: "customer-id-นาย-A"
// status: "pending" (รอชำระเงิน)
// createdAt: 2023-10-27 10:00:00
// Step 2: สร้างรายการสินค้า (Create OrderItems)
// ระบบจะสร้าง Record ในตาราง OrderItem ตามจำนวนชนิดสินค้าที่เลือก โดยผูกกับ Order ที่เพิ่งสร้าง

// Model OrderItem (รายการที่ 1):
// orderId: "order-001"
// productId: "product-id-iphone"
// quantity: 1
// price: 30000
// Model OrderItem (รายการที่ 2):
// orderId: "order-001"
// productId: "product-id-case"
// quantity: 2
// price: 500
// Step 3: การชำระเงิน (Process Payment)
// เมื่อนาย A จ่ายเงินสำเร็จ ระบบจะสร้าง Record ในตาราง Payment

// Model Payment:
// orderId: "order-001"
// amount: 31000 (ยอดรวม)
// status: "success"
// provider: "stripe"
// Step 4: อัปเดตสถานะ (Update Status)
// เมื่อ Payment สำเร็จ ระบบจะกลับไปอัปเดตสถานะใน Order

// Model Order:
// status: เปลี่ยนจาก "pending" -> "paid"
// สรุปภาพรวม
// โครงสร้างนี้ช่วยให้ระบบมีความยืดหยุ่นครับ เช่น:

// แยก Product ออกจาก OrderItem: ถ้าในอนาคตเราแก้ชื่อสินค้าใน Product ข้อมูลในใบสั่งซื้อเก่าๆ (OrderItem) ก็ยังคงถูกต้องเพราะเรามักจะ snapshot ราคา (price) ไว้ที่ OrderItem ตอนสั่งซื้อด้วย
// แยก Payment: ทำให้รองรับกรณีที่สั่งซื้อแล้วแต่ยังไม่จ่าย หรือจ่ายไม่สำเร็จได้ง่าย
// model Product {
//   id          Int          @id @default(autoincrement())
//   name        String
//   price       Int
//   orderItems  OrderItem[]
//   invoiceItems InvoiceItem[]
// }

// model Order {
//   id          Int          @id @default(autoincrement())
//   customerId  Int
//   createdAt   DateTime     @default(now())
//   orderItems  OrderItem[]
//   payment     Payment?
// }

// model Invoice {
//   id          Int          @id @default(autoincrement())
//   customerId  Int
//   createdAt   DateTime     @default(now())
//   invoiceItems InvoiceItem[]
// }

// model OrderItem {
//   id        Int     @id @default(autoincrement())
//   orderId   Int
//   productId Int
//   quantity  Int
//   amount    Int

//   // Relations
//   order   Order   @relation(fields: [orderId], references: [id])
//   product Product @relation(fields: [productId], references: [id])
// }

// model InvoiceItem {
//   id        Int     @id @default(autoincrement())
//   invoiceId Int
//   productId Int
//   quantity  Int
//   amount    Int

//   // Relations
//   invoice  Invoice @relation(fields: [invoiceId], references: [id])
//   product  Product @relation(fields: [productId], references: [id])
// }

// model Payment {
//   id        Int     @id @default(autoincrement())
//   orderId   Int     @unique
//   method    String
//   status    String

//   // Relation
//   order Order @relation(fields: [orderId], references: [id])
// }
//============================================================================
//วาด ER Diagram แบบข้อความ ASCII

// User (1) ──── (1) Customer ────< (N) Address
//                   │
//                   ├───< (N) Order ────< (N) OrderItem >──── (1) Product
//                   │        │
//                   │        ├─── (1) Payment
//                   │        | 
//                   │        └─── (1) ShippingInfo
//                   │
//                   │
//                   └───< (N) Invoice ────< (N) InvoiceItem >──── (1) Product

// User (1) ────< (N) Order ────< (N) OrderItem >──── (1) Product
//                   │                 │
//                   │                 └───< (N) Review
//                   │
//                   ├─── (1) Payment
//                   │
//                   └─── (1) ShippingInfo
//
// - User (1) ────< (N) Order
// - ผู้ใช้หนึ่งคนสามารถมีหลายคำสั่งซื้อ (Order)
// - Order ────< (N) OrderItem >──── (1) Product
// - คำสั่งซื้อหนึ่งมีหลายรายการสินค้า (OrderItem)
// - แต่ละ OrderItem อ้างอิงไปยัง Product หนึ่งตัว
// - OrderItem └───< (N) Review
// - สินค้า (Product) สามารถมีหลาย Review จากผู้ใช้
// - Review เชื่อมโยงกับทั้ง Product และ User
// - Order ──── (1) Payment
// - คำสั่งซื้อหนึ่งมีการชำระเงินหนึ่งครั้ง (Payment)
// - Order ──── (1) ShippingInfo
// - คำสั่งซื้อหนึ่งมีข้อมูลการจัดส่งหนึ่งชุด (ShippingInfo
